---
phase: 05-drag-to-reorder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - QuickTask/Sources/Store/TaskStore.swift
  - QuickTask/Sources/Views/TaskListView.swift
  - QuickTask/Sources/Views/TaskRowView.swift
autonomous: true
requirements:
  - REOR-01
  - REOR-02
  - REOR-03

must_haves:
  truths:
    - "Each task row shows a drag handle icon (three-bar grip) to the left of the checkbox"
    - "Hovering the drag handle and dragging reorders the task list in real time"
    - "Tapping the checkbox works normally with no gesture delay or accidental reorder trigger"
    - "Task order after a drag persists across app quit and relaunch"
  artifacts:
    - path: "QuickTask/Sources/Store/TaskStore.swift"
      provides: "move(fromOffsets:toOffset:) mutation method"
      contains: "func move(fromOffsets"
    - path: "QuickTask/Sources/Views/TaskListView.swift"
      provides: "ForEach with onMove wired to store.move"
      contains: ".onMove"
    - path: "QuickTask/Sources/Views/TaskRowView.swift"
      provides: "Drag handle icon with onHover gating moveDisabled"
      contains: "moveDisabled"
  key_links:
    - from: "QuickTask/Sources/Views/TaskListView.swift"
      to: "QuickTask/Sources/Store/TaskStore.swift"
      via: "onMove closure calling store.move(fromOffsets:toOffset:)"
      pattern: "store\\.move"
    - from: "QuickTask/Sources/Views/TaskRowView.swift"
      to: "QuickTask/Sources/Views/TaskListView.swift"
      via: "moveDisabled(!isHovering) gates which rows are draggable; onMove on ForEach activates the drag"
      pattern: "moveDisabled.*isHovering"
---

<objective>
Add drag-to-reorder to the task list via a visible drag handle on each row. Users grab the handle to reorder; the checkbox and delete button remain unaffected. Reordered tasks persist across app restarts.

Purpose: Lets users manually prioritize tasks — the most important task sits at the top. Order persists so priority decisions survive restarts.
Output: Modified TaskStore (move mutation), TaskListView (ForEach + onMove), TaskRowView (drag handle + moveDisabled gate).
</objective>

<execution_context>
@/home/rob/.claude/get-shit-done/workflows/execute-plan.md
@/home/rob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-drag-to-reorder/05-RESEARCH.md
@QuickTask/Sources/Store/TaskStore.swift
@QuickTask/Sources/Views/TaskListView.swift
@QuickTask/Sources/Views/TaskRowView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add move(fromOffsets:toOffset:) mutation to TaskStore</name>
  <files>QuickTask/Sources/Store/TaskStore.swift</files>
  <action>
Add a `move(fromOffsets:toOffset:)` method to TaskStore, following the established mutation pattern (add, toggle, delete all call persist() as their last line).

In the `// MARK: - Mutations` section, after the `delete(_:)` method, add:

```swift
/// Reorders tasks by moving items at the given offsets to the new position.
/// Called from TaskListView's onMove closure when the user drags a task via its handle.
func move(fromOffsets source: IndexSet, toOffset destination: Int) {
    tasks.move(fromOffsets: source, toOffset: destination)
    persist()
}
```

This uses `Array.move(fromOffsets:toOffset:)` from Swift stdlib — it matches the `onMove` closure signature exactly. The `persist()` call writes the reordered array to JSON, preserving order across restarts (REOR-02). No changes to the `Task` struct are needed because array index order IS the persisted order.

Do NOT add a sortOrder field to Task. Do NOT change any existing methods.
  </action>
  <verify>The file compiles with the new method. Confirm `move(fromOffsets:toOffset:)` exists in TaskStore and calls `persist()` as its last line. Verify the method signature matches: `func move(fromOffsets source: IndexSet, toOffset destination: Int)`.</verify>
  <done>TaskStore has a `move(fromOffsets:toOffset:)` method that reorders the in-memory array and persists the new order. The method follows the same mutation pattern as add/toggle/delete.</done>
</task>

<task type="auto">
  <name>Task 2: Wire drag handle, onMove, and moveDisabled in TaskListView and TaskRowView</name>
  <files>QuickTask/Sources/Views/TaskListView.swift, QuickTask/Sources/Views/TaskRowView.swift</files>
  <action>
**TaskListView.swift** — Replace `List(store.tasks)` with `List { ForEach(...).onMove { ... } }`:

The current code is:
```swift
List(store.tasks) { task in
    TaskRowView(task: task)
        .listRowSeparator(.hidden)
}
```

Replace with:
```swift
List {
    ForEach(store.tasks) { task in
        TaskRowView(task: task)
            .listRowSeparator(.hidden)
    }
    .onMove { indices, newOffset in
        store.move(fromOffsets: indices, toOffset: newOffset)
    }
}
```

CRITICAL: `onMove` MUST be on the `ForEach`, not on the `List`. This is the only correct placement — `onMove` is defined on `DynamicViewContent` which `ForEach` conforms to. Placing it elsewhere silently does nothing.

Do NOT use `ForEach($store.tasks, editActions: [.move])` — the binding form auto-mutates without calling `persist()`.
Do NOT use `ForEach(0..<store.tasks.count)` — integer-range ForEach causes index-out-of-range crash on drag completion.
Do NOT add `.environment(\.editMode, .constant(.active))` — macOS does not require edit mode for onMove.

Keep `.listStyle(.plain)` and the `.overlay { ... }` empty state exactly as they are.

---

**TaskRowView.swift** — Add drag handle icon with `isHovering` state and `moveDisabled` gate:

1. Add a `@State private var isHovering = false` property after the existing `let task: Task` line.

2. Inside the `HStack`, BEFORE the `Toggle`, add the drag handle:
```swift
Image(systemName: "line.3.horizontal")
    .foregroundStyle(.tertiary)
    .onHover { hovering in
        isHovering = hovering
    }
```

The handle uses `.foregroundStyle(.tertiary)` (not `.secondary`) to be visually present but subordinate to the checkbox and text. SF Symbol `"line.3.horizontal"` is the standard three-bar grip icon.

3. After the `.animation(...)` line (the last modifier on the HStack), add:
```swift
.moveDisabled(!isHovering)
```

This means: drag is DISABLED unless the pointer is hovering over the drag handle. When the user hovers the handle, `isHovering` becomes `true`, `moveDisabled(false)` allows the drag to initiate. During an active drag, SwiftUI does not update `onHover`, so `isHovering` stays `true` for the drag duration (MEDIUM confidence — hardware validate).

CRITICAL per STATE.md decision: `moveDisabled` + `onHover` drag handle pattern is required from first line — not a retrofit. The `@State var isHovering` MUST be inside TaskRowView (not in the parent TaskListView) so each row has its own independent hover state. A shared isHovering would allow dragging any row when hovering any other row's handle.

Do NOT add `.onTapGesture` to the row HStack — known macOS bug (FB7367473) causes it to break the onMove blue-line indicator.
Do NOT use `NSCursor.openHand`/`.closedHand` — optional polish deferred, not in requirements.
  </action>
  <verify>
1. TaskListView uses `List { ForEach(store.tasks) { ... }.onMove { ... } }` pattern (not `List(store.tasks)`).
2. TaskRowView has `@State private var isHovering = false` as an instance property.
3. TaskRowView body starts with `Image(systemName: "line.3.horizontal")` with `.onHover` before the Toggle.
4. TaskRowView HStack has `.moveDisabled(!isHovering)` as its last modifier.
5. No `.onTapGesture` on the row HStack.
6. No `ForEach(0..<...)` integer range form.
7. No `editActions:` binding form on ForEach.
  </verify>
  <done>
Each task row shows a drag handle icon (three-bar grip) to the left of the checkbox (REOR-03). Hovering the handle enables drag; the onMove closure calls store.move which persists the new order (REOR-01, REOR-02). The checkbox Toggle works without gesture interference because moveDisabled(true) is the default state — only handle hover enables drag.
  </done>
</task>

</tasks>

<verification>
1. TaskStore.swift contains `func move(fromOffsets source: IndexSet, toOffset destination: Int)` that calls `persist()`
2. TaskListView.swift uses `ForEach(store.tasks).onMove { store.move(...) }` inside a `List { }` block
3. TaskRowView.swift has `@State private var isHovering = false` scoped per-row (not shared)
4. TaskRowView.swift has `Image(systemName: "line.3.horizontal")` with `.onHover` as the first item in HStack
5. TaskRowView.swift has `.moveDisabled(!isHovering)` on the row container
6. No new files created — all changes in existing files
7. No new dependencies — all APIs are SwiftUI stdlib (macOS 10.15+)
8. Hardware validation blocker acknowledged — MEDIUM confidence on onHover + moveDisabled runtime behavior
</verification>

<success_criteria>
- TaskStore has move mutation method following established add/toggle/delete pattern
- TaskListView uses ForEach + onMove (not List initializer) for drag reorder activation
- TaskRowView has visible drag handle icon with onHover-gated moveDisabled
- Each row's isHovering state is independent (no shared parent state)
- Drag handle is visually distinct from checkbox (different icon, tertiary foreground)
- No gesture conflicts between drag handle and checkbox toggle
- Order persistence uses existing array-index serialization (no schema changes)
</success_criteria>

<output>
After completion, create `.planning/phases/05-drag-to-reorder/05-01-SUMMARY.md`
</output>
