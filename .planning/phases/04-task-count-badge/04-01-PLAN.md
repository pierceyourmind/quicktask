---
phase: 04-task-count-badge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - QuickTask/Sources/Store/TaskStore.swift
  - QuickTask/Sources/App/AppDelegate.swift
autonomous: true
requirements:
  - BADGE-01
  - BADGE-02

must_haves:
  truths:
    - "Menu bar icon shows the count of incomplete tasks as a plain number to the right of the icon"
    - "Badge number updates instantly when a task is added, completed, or deleted"
    - "Badge disappears and icon reverts to icon-only when all tasks are completed or list is empty"
    - "Badge text is legible in both light mode and dark mode without manual color management"
  artifacts:
    - path: "QuickTask/Sources/Store/TaskStore.swift"
      provides: "Computed incompleteCount property"
      contains: "incompleteCount"
    - path: "QuickTask/Sources/App/AppDelegate.swift"
      provides: "Badge rendering on NSStatusItem with reactive observation"
      contains: "variableLength"
  key_links:
    - from: "QuickTask/Sources/App/AppDelegate.swift"
      to: "QuickTask/Sources/Store/TaskStore.swift"
      via: "Observation framework withObservationTracking on incompleteCount"
      pattern: "withObservationTracking|incompleteCount"
---

<objective>
Wire the menu bar NSStatusItem to display a live count of incomplete tasks as a plain number next to the icon. The badge appears when 1+ tasks are incomplete and disappears at zero, reverting to icon-only.

Purpose: Users see at a glance how many tasks need attention without opening the panel.
Output: Modified AppDelegate.swift (badge rendering + reactive observation) and TaskStore.swift (incompleteCount property).
</objective>

<execution_context>
@/home/rob/.claude/get-shit-done/workflows/execute-plan.md
@/home/rob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@QuickTask/Sources/App/AppDelegate.swift
@QuickTask/Sources/Store/TaskStore.swift
@QuickTask/Sources/Panel/PanelManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add incompleteCount to TaskStore and retain store reference in AppDelegate</name>
  <files>QuickTask/Sources/Store/TaskStore.swift, QuickTask/Sources/App/AppDelegate.swift</files>
  <action>
In `TaskStore.swift`, add a computed property `incompleteCount` that returns the count of tasks where `isCompleted == false`:

```swift
var incompleteCount: Int {
    tasks.filter { !$0.isCompleted }.count
}
```

This is a computed property on an @Observable class. When SwiftUI or `withObservationTracking` reads `incompleteCount`, the Observation framework tracks the access to `tasks` and will trigger re-observation when `tasks` changes. No additional notification machinery needed.

In `AppDelegate.swift`, change `applicationDidFinishLaunching` so that:
1. Create `TaskStore()` as before, but capture it in a new `private var taskStore: TaskStore!` instance property on AppDelegate (instead of creating an anonymous instance).
2. Pass it to `PanelManager.shared.configure(with: taskStore)` as before.
3. After configure, call a new method `observeBadge()` (implemented in Task 2).

This refactor gives AppDelegate a retained reference to TaskStore for badge observation. The flow becomes:
```
let store = TaskStore()
self.taskStore = store
PanelManager.shared.configure(with: store)
setupStatusItem()  // still before or after — order doesn't matter for badge
observeBadge()     // new — starts reactive loop
```
  </action>
  <verify>
Both files compile conceptually (no Xcode on Linux — verify syntax is valid Swift 5.10). `incompleteCount` returns correct count for empty list (0), all complete (0), mixed (count of incomplete only).
  </verify>
  <done>TaskStore exposes `incompleteCount` computed property. AppDelegate holds a `private var taskStore: TaskStore!` reference. `observeBadge()` is called in launch sequence (implemented in Task 2).</done>
</task>

<task type="auto">
  <name>Task 2: Implement badge rendering on NSStatusItem with reactive observation</name>
  <files>QuickTask/Sources/App/AppDelegate.swift</files>
  <action>
Implement the badge display and reactive observation loop in AppDelegate.

**1. Change status item length to variable.**

In `setupStatusItem()`, change:
```swift
statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)
```
to:
```swift
statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
```
Per user decision: `variableLength` NSStatusItem so the item width adjusts naturally as digit count changes. This is the standard approach for status items that display text alongside an icon.

**2. Create `updateBadge()` method.**

Add a private method that reads the current count and updates the button title:
```swift
private func updateBadge() {
    guard let button = statusItem.button else { return }
    let count = taskStore.incompleteCount
    if count > 0 {
        button.title = " \(count)"
    } else {
        button.title = ""
    }
}
```

Key details per locked user decisions:
- Plain number, no background shape, no colored circle.
- `button.title` is the display mechanism (per STATE.md decision: "Use `button.title` (not image compositing) for badge").
- A leading space `" \(count)"` provides natural spacing between the icon and the number. This is Claude's discretion for number positioning — a single space is the standard macOS menu bar convention for icon+text status items.
- System font is used by default for `button.title` — this gives system regular weight and system adaptive color (white in dark mode, black in light mode) automatically. No custom font or color attributes needed.
- When count is 0, set `button.title = ""` to hide the badge entirely (icon-only). Per user decision: "Badge hidden when count is zero."
- No animation, no fade — instant swap per user decision.
- No cap at 99+ — show real count per user decision.

**3. Create `observeBadge()` method with Observation tracking loop.**

Use `withObservationTracking` from the Observation framework to reactively track `incompleteCount`:

```swift
private func observeBadge() {
    // Initial badge update from persisted data — show immediately at launch
    updateBadge()

    // Set up reactive observation. withObservationTracking calls the first closure
    // immediately and tracks which @Observable properties are read. When any tracked
    // property changes, the onChange closure fires (on an arbitrary thread).
    withObservationTracking {
        _ = self.taskStore.incompleteCount
    } onChange: { [weak self] in
        // onChange fires once per change, on an arbitrary thread.
        // Dispatch to main for UI update + re-register observation.
        DispatchQueue.main.async {
            self?.updateBadge()
            self?.observeBadge()  // Re-register — withObservationTracking is one-shot
        }
    }
}
```

IMPORTANT: `withObservationTracking` is one-shot — it fires `onChange` exactly once, then stops observing. The recursive `observeBadge()` call re-registers for the next change. This is the standard Observation framework pattern for non-SwiftUI contexts (AppKit code cannot use @Observable auto-tracking like SwiftUI views do).

**4. Call order in applicationDidFinishLaunching.**

The final launch sequence:
```swift
NSApp.setActivationPolicy(.accessory)
setupStatusItem()
let store = TaskStore()
self.taskStore = store
PanelManager.shared.configure(with: store)
HotkeyService.shared.register()
observeBadge()
```

`observeBadge()` is called after `setupStatusItem()` (statusItem must exist) and after TaskStore is created (taskStore must exist). The initial `updateBadge()` inside `observeBadge()` displays the correct count from persisted data immediately at launch.
  </action>
  <verify>
1. Read the final AppDelegate.swift and verify: `variableLength` is used, `updateBadge()` sets title to " N" or "", `observeBadge()` uses `withObservationTracking` with recursive re-registration.
2. Verify `import Observation` is present in AppDelegate.swift (needed for `withObservationTracking`).
3. Trace the reactive chain: TaskStore.add() -> tasks mutates -> @Observable notifies -> withObservationTracking onChange fires -> updateBadge() reads new incompleteCount -> button.title updated. Same for toggle() and delete().
4. Verify badge at zero: when last task is completed or deleted, `incompleteCount` returns 0, `button.title` becomes "", icon reverts to icon-only.
  </verify>
  <done>
Menu bar NSStatusItem displays incomplete task count as plain number next to icon. Count updates reactively on every add/toggle/delete. Badge disappears at zero count. System font and color used for automatic light/dark mode adaptation. No animation, no cap, no Settings toggle.
  </done>
</task>

</tasks>

<verification>
1. Review AppDelegate.swift for correct `variableLength`, `updateBadge()`, and `observeBadge()` implementation
2. Review TaskStore.swift for `incompleteCount` computed property
3. Trace full reactive chain: mutation -> @Observable -> withObservationTracking -> updateBadge -> button.title
4. Verify edge cases: zero tasks (no badge), all complete (no badge), 1 incomplete (shows "1"), 100+ incomplete (shows real number)
5. Verify light/dark mode: button.title uses system default font and color — no custom NSAttributedString or explicit color setting
6. Confirm no animation code exists — title swaps are instant
</verification>

<success_criteria>
- AppDelegate.swift uses `NSStatusItem.variableLength` instead of `squareLength`
- TaskStore.swift exposes `incompleteCount` computed property
- `updateBadge()` sets `button.title` to `" N"` (with leading space) when count > 0, `""` when 0
- `observeBadge()` uses `withObservationTracking` with one-shot + recursive re-registration pattern
- Badge updates on add, toggle, and delete — no polling, no timer, no manual refresh
- At zero count, button.title is empty string (icon-only display)
- No custom colors, no custom fonts — system defaults handle light/dark adaptation
</success_criteria>

<output>
After completion, create `.planning/phases/04-task-count-badge/04-01-SUMMARY.md`
</output>
