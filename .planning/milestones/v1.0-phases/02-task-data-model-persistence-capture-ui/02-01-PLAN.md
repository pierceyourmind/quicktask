---
phase: 02-task-data-model-persistence-capture-ui
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - QuickTask/Sources/Model/Task.swift
  - QuickTask/Sources/Persistence/FileStore.swift
  - QuickTask/Sources/Persistence/TaskRepository.swift
  - QuickTask/Sources/Store/TaskStore.swift
  - QuickTask/Sources/Panel/PanelManager.swift
  - QuickTask/Sources/App/AppDelegate.swift
autonomous: true
requirements: [PERS-01, PERS-02, PERS-03]

must_haves:
  truths:
    - "Tasks persist across app quit and relaunch"
    - "Tasks persist across system reboot"
    - "Task data is stored as JSON at ~/Library/Application Support/QuickTask/tasks.json"
    - "TaskStore is accessible from SwiftUI views via @Environment"
  artifacts:
    - path: "QuickTask/Sources/Model/Task.swift"
      provides: "Task value type with id, title, isCompleted, createdAt"
      contains: "struct Task: Codable, Identifiable"
    - path: "QuickTask/Sources/Persistence/FileStore.swift"
      provides: "JSON read/write to Application Support directory"
      contains: "func load() -> [Task]"
    - path: "QuickTask/Sources/Persistence/TaskRepository.swift"
      provides: "CRUD abstraction over FileStore"
      contains: "struct TaskRepository"
    - path: "QuickTask/Sources/Store/TaskStore.swift"
      provides: "Observable single source of truth for task list"
      contains: "@Observable"
  key_links:
    - from: "QuickTask/Sources/Store/TaskStore.swift"
      to: "QuickTask/Sources/Persistence/TaskRepository.swift"
      via: "private let repository = TaskRepository()"
      pattern: "TaskRepository"
    - from: "QuickTask/Sources/Persistence/TaskRepository.swift"
      to: "QuickTask/Sources/Persistence/FileStore.swift"
      via: "private let store = FileStore()"
      pattern: "FileStore"
    - from: "QuickTask/Sources/Panel/PanelManager.swift"
      to: "QuickTask/Sources/Store/TaskStore.swift"
      via: "environment injection into NSHostingView rootView"
      pattern: "\\.environment\\(.*taskStore"
    - from: "QuickTask/Sources/App/AppDelegate.swift"
      to: "QuickTask/Sources/Panel/PanelManager.swift"
      via: "configure(with:) call in applicationDidFinishLaunching"
      pattern: "PanelManager\\.shared\\.configure"
---

<objective>
Create the complete data layer (Task model, FileStore, TaskRepository, TaskStore) and wire TaskStore into the NSPanel's SwiftUI environment so views in later plans can access it via @Environment(TaskStore.self).

Purpose: Establishes the persistence foundation that all UI plans depend on. Without this layer, views have nothing to read from or write to, and tasks cannot survive app restarts.

Output: Four new Swift files (Model/Task.swift, Persistence/FileStore.swift, Persistence/TaskRepository.swift, Store/TaskStore.swift) and two updated files (PanelManager.swift, AppDelegate.swift) with TaskStore wiring.
</objective>

<execution_context>
@/home/rob/.claude/get-shit-done/workflows/execute-plan.md
@/home/rob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-task-data-model-persistence-capture-ui/02-RESEARCH.md
@QuickTask/Sources/Panel/PanelManager.swift
@QuickTask/Sources/App/AppDelegate.swift
@QuickTask/Sources/Panel/FloatingPanel.swift
@QuickTask/Sources/Views/ContentView.swift
@QuickTask/Package.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Task model, FileStore, TaskRepository, and TaskStore</name>
  <files>
    QuickTask/Sources/Model/Task.swift
    QuickTask/Sources/Persistence/FileStore.swift
    QuickTask/Sources/Persistence/TaskRepository.swift
    QuickTask/Sources/Store/TaskStore.swift
  </files>
  <action>
Create four new files following the bottom-up data layer architecture from research.

**QuickTask/Sources/Model/Task.swift:**
- `struct Task: Codable, Identifiable` with `let id: UUID`, `var title: String`, `var isCompleted: Bool`, `let createdAt: Date`
- Convenience `init(title: String)` that sets `id = UUID()`, `isCompleted = false`, `createdAt = Date()`
- Import Foundation only

**QuickTask/Sources/Persistence/FileStore.swift:**
- `struct FileStore` with `private let fileURL: URL`
- In `init()`: resolve `~/Library/Application Support/QuickTask/` via `FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!.appendingPathComponent("QuickTask", isDirectory: true)`. Call `try? FileManager.default.createDirectory(at:withIntermediateDirectories:true, attributes:nil)` to ensure the directory exists (CRITICAL: Application Support sub-directories are NOT auto-created). Set `fileURL = appSupport.appendingPathComponent("tasks.json")`
- `func load() -> [Task]`: read Data from fileURL, decode with JSONDecoder, return empty array on any failure
- `func save(_ tasks: [Task])`: encode with JSONEncoder, write with `data.write(to: fileURL, options: .atomic)` (CRITICAL: .atomic prevents data corruption on force-quit). Use `try?` to silently handle write failures

**QuickTask/Sources/Persistence/TaskRepository.swift:**
- `struct TaskRepository` with `private let store = FileStore()`
- `func loadAll() -> [Task]` delegates to `store.load()`
- `func save(_ tasks: [Task])` delegates to `store.save(tasks)`
- This layer is intentionally thin — it is the abstraction boundary so FileStore can be swapped later without changing TaskStore

**QuickTask/Sources/Store/TaskStore.swift:**
- `import Foundation` and `import Observation`
- `@Observable final class TaskStore`
- `var tasks: [Task] = []` (the single source of truth)
- `private let repository = TaskRepository()`
- `init()`: load tasks from repository on creation (`tasks = repository.loadAll()`)
- `func add(title: String)`: guard against whitespace-only titles (`title.trimmingCharacters(in: .whitespaces).isEmpty`), append new Task, call `persist()`
- `func toggle(_ task: Task)`: find task by id using `firstIndex(where:)`, toggle `isCompleted`, call `persist()`
- `func delete(_ task: Task)`: `removeAll { $0.id == task.id }`, call `persist()`
- `private func persist()`: call `repository.save(tasks)` — synchronous write on every mutation (acceptable for < 500 tasks per research)

Note: Do NOT use `@StateObject`, `ObservableObject`, `@Published`, or Combine. Use `@Observable` macro with `@State` at owner and `@Environment` in children (macOS 14+ pattern per research).
  </action>
  <verify>
Verify all four files exist and contain required patterns:
- Task.swift contains `struct Task: Codable, Identifiable` with `id`, `title`, `isCompleted`, `createdAt` fields
- FileStore.swift contains `createDirectory`, `applicationSupportDirectory`, `.atomic`, `load()`, `save()`
- TaskRepository.swift contains `struct TaskRepository`, `loadAll()`, `save()`
- TaskStore.swift contains `@Observable`, `func add(`, `func toggle(`, `func delete(`, `func persist()` or `private func persist()`
  </verify>
  <done>
Four files exist at the correct paths. Task is Codable+Identifiable with four fields. FileStore creates the Application Support subdirectory and uses .atomic writes. TaskRepository delegates to FileStore. TaskStore is @Observable with add/toggle/delete/persist methods and loads from repository on init.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TaskStore into PanelManager and AppDelegate</name>
  <files>
    QuickTask/Sources/Panel/PanelManager.swift
    QuickTask/Sources/App/AppDelegate.swift
  </files>
  <action>
Update PanelManager and AppDelegate so that TaskStore is created at launch and injected into the SwiftUI environment of the NSPanel's hosting view.

**QuickTask/Sources/App/AppDelegate.swift:**
- In `applicationDidFinishLaunching`, BEFORE `HotkeyService.shared.register()`, add: `PanelManager.shared.configure(with: TaskStore())`
- This creates the single TaskStore instance at app launch and passes it to PanelManager

**QuickTask/Sources/Panel/PanelManager.swift:**
- Add `private var taskStore: TaskStore?` property
- Add `func configure(with store: TaskStore)` method that stores the reference: `self.taskStore = store`
- Change the `lazy var panel` to use the taskStore in the NSHostingView. Replace the current lazy panel initialization with a non-lazy `private var panel: FloatingPanel<some View>?` property.
- In `configure(with:)`, after storing the store, create the panel: `panel = FloatingPanel(rootView: ContentView().environment(store))`
- Update `show()`, `hide()`, `toggle()`, and `resignKey` references to use `panel` as an optional (`panel?.orderFrontRegardless()`, etc.) or guard-let unwrap
- CRITICAL: The `.environment(store)` call on the rootView is what makes `@Environment(TaskStore.self)` work in child views. NSHostingView creates an isolated SwiftUI environment — the store MUST be injected here, not from QuickTaskApp's body (which is just `Settings { EmptyView() }`)

Important: Do NOT change FloatingPanel.swift — it remains generic over `Content: View`. Do NOT change QuickTaskApp.swift — it stays as-is with `Settings { EmptyView() }`. Do NOT make TaskStore a singleton — it is created in AppDelegate and passed to PanelManager via configure().
  </action>
  <verify>
Verify the wiring:
- AppDelegate.swift contains `PanelManager.shared.configure(with: TaskStore())`
- PanelManager.swift contains `func configure(with store: TaskStore)`, `.environment(store)` or `.environment(taskStore)`, and `private var taskStore`
- PanelManager still has `toggle()`, `show()`, `hide()` methods that reference the panel
  </verify>
  <done>
AppDelegate creates TaskStore and passes it to PanelManager.configure(with:). PanelManager stores the TaskStore reference and creates FloatingPanel with ContentView().environment(store) as the rootView. The @Environment(TaskStore.self) pattern is available to all SwiftUI views hosted in the panel.
  </done>
</task>

</tasks>

<verification>
- All 6 files exist at correct paths under QuickTask/Sources/
- Data flow: TaskStore -> TaskRepository -> FileStore -> ~/Library/Application Support/QuickTask/tasks.json
- Injection flow: AppDelegate creates TaskStore -> PanelManager.configure(with:) -> FloatingPanel(rootView: ContentView().environment(store))
- No Combine imports, no ObservableObject, no @Published, no @StateObject anywhere
- FileStore.init() creates the Application Support subdirectory
- FileStore.save() uses .atomic option
- TaskStore.add() guards against empty/whitespace-only titles
</verification>

<success_criteria>
- Task model is Codable and Identifiable with UUID id, String title, Bool isCompleted, Date createdAt
- FileStore reads/writes JSON to ~/Library/Application Support/QuickTask/tasks.json with .atomic writes
- TaskRepository provides loadAll/save abstraction over FileStore
- TaskStore is @Observable with add/toggle/delete that persist synchronously
- PanelManager receives TaskStore via configure(with:) and injects it into ContentView's environment
- AppDelegate creates TaskStore and calls PanelManager.shared.configure(with:) at launch
</success_criteria>

<output>
After completion, create `.planning/phases/02-task-data-model-persistence-capture-ui/02-01-SUMMARY.md`
</output>
